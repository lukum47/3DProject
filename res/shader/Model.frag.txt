#version 460
out vec4 frag_color;
in vec2 texCoords;
in vec3 norm;
in vec3 fragPos;

uniform vec3 viewPos;

struct Material
{
 sampler2D diffuse;
 sampler2D specular;

};
uniform Material materials;

uniform vec3 lightColor;
uniform vec3 objectColor;
struct PointLight {
vec3 position;

float constant;
float linear;
float quadratic;

vec3 ambient;
vec3 diffuse;
vec3 specular;
};

uniform PointLight pointLight;

vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir);
void main() 
{
	vec3 normal = normalize(norm);
	vec3 viewDir = normalize(viewPos - fragPos);
vec3 lightDir = normalize(pointLight.position - fragPos);
float diff = max(dot(normal, lightDir), 0.0);
	vec3 result = CalcPointLight(pointLight, normal, fragPos, viewDir);
	float distance = length(pointLight.position - fragPos);
float autenuation = 1.0/ (pointLight.constant + pointLight.linear * distance + pointLight.quadratic * (distance * distance));
	vec3 reflectDir = reflect(-lightDir, normal);
	float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
	//frag_color = vec4(result, 1.0);
	 vec4 ambient = vec4(pointLight.ambient, 1.0) * vec4(lightColor, 1.0)* texture(materials.diffuse, texCoords);
	vec4 diffuse =  vec4(pointLight.diffuse, 1.0) * diff * vec4(lightColor, 1.0)  * texture(materials.diffuse, texCoords);
	vec4 specular = vec4(pointLight.specular, 1.0) * spec * vec4(lightColor, 1.0)  * texture(materials.specular, texCoords);

	frag_color = ambient + diffuse + specular; //vec4(pointLight.diffuse, 1.0) * diff * vec4(lightColor, 1.0)  * texture(materials.diffuse, texCoords);

}

vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir) {

vec3 lightDir = normalize(light.position - fragPos);
//расчет диффузного освещения 
float diff = max(dot(normal, lightDir), 0.0);
// рассчет бликового освещения 
vec3 reflectionDir = reflect(-lightDir, normal); // направление отражения света 
float spec = pow(max(dot(viewDir, reflectionDir), 0.0), 32.0);	
//затухание 
float distance = length(light.position - fragPos);
float autenuation = 1.0/ (light.constant + light.linear * distance + 
  			     light.quadratic * (distance * distance));  
vec3 ambient = light.ambient * lightColor * objectColor; //vec3(texture(materials.diffuse, texCoords));
vec3 diffuse = light.diffuse * diff * lightColor * objectColor * vec3(texture(materials.diffuse, texCoords));
vec3 specular = light.specular * spec  * vec3(texture(materials.specular, texCoords));

ambient *= autenuation;
diffuse *= autenuation;
specular *= autenuation;

//return(ambient + diffuse + specular);
return diffuse;

}